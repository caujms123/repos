#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include "front.h"
using namespace std;

//*******************************************************************************************************************
/* Function expr
   Parses strings in the language
   generated by the rule:
   <expr> → <term> {(+ | -) <term>}
 */
Parser::Parser(Lexer &lexer, var* start) :lexer(lexer) {
	this->start = start;
}

var Parser::program() {
	/*program -> (<stmt_list>)[; ] | 변수명 | 상수 | 문자열 | '(quote) 띄어쓰기 또는 괄호로 닫혀있는 곳까지 읽음
		*/
	var result;
	printf("Enter <program>\n");
	lex();
	while (nextToken == LEFT_PAREN == SEMICOLON) { // 끝에 ;가 몇 개가 오던간에 모두 걸러냄
		lex();
	}
	if (nextToken == LEFT_PAREN) { // ( (<stmt_list>) 처리
		lex();
		if (isReturnNum()) returnIsNum();
		else if (isReturnList())returnIsList();
		else if (isReturnStr())returnIsStr();
		else if (isReturnF())returnIsF();
		else if (isReturnTF())returnIsTF();
		else error();
		if (nextToken != RIGHT_PAREN) error();
	}

	else if (nextToken == IDENT) { // 변수일 때 반환( find 함수로 찾아서 안나오면 오류, 나오면 result 에 넣음)
		var* ident = start->find(lexeme(),start);
		if (ident == NULL) {
			error();
		}
		else result = *ident;
	}
	else if (nextToken == INT_LIT && nextToken == DOUBLE_LIT) { //  상수면 result = lexeme(); = 오버로딩 해야할듯
		result = lexeme();
	}
	else if (nextToken == QUOTE_CODE) { // quote는 string을 반환함 () 묶여있거나 띄어쓰기 까지
		//result = quote();
	}
	else error();
	printf("Exit <program>\n");
	return result;
}
var Parser::returnIsNum(void) {//return 값이 숫자인 모든 데이터,함수들 (후보를 갖고 있으면 전부 포함) 
							   //return이 number면 무조건 다음 return도 number여야한다.
	var result;
	switch (nextToken)
	{
	case ADD_OP: // 인자에 4 또는 변수 또는 (stmt_list)(return 값이 숫자) 또는 ' 올 수 있음. 
		lex();
		switch (nextToken) { // 상수 변수 '인 경우
		case INT_LIT: result = stoi(lexeme()); break;
		case DOUBLE_LIT: result = stod(lexeme()); break;
		case IDENT: result = *(start->find(lexeme(),start)); break;
		case QUOTE_CODE:// result = quote(); break;
		case LEFT_PAREN:
			if (isReturnNum()) {
				result = returnIsNum();
				lex();
				if (nextToken != RIGHT_PAREN) error();
			}
		default:error();
		}
		lex();
		switch (nextToken) { // 상수 변수 '인 경우
		case INT_LIT: result = result + stoi(lexeme()); break;
		case DOUBLE_LIT: result = result + stod(lexeme()); break;
		case IDENT: result = result + *(start->find(lexeme(),start)); break;
		case QUOTE_CODE: //result = result + quote(); break; //quote가 숫자를 반환하는지 확인이 필요함
		case LEFT_PAREN:
			if (isReturnNum()) {
				result = result + returnIsNum();
				lex();
				if (nextToken != RIGHT_PAREN) error();
			}
		default:error();
		}
		break;
	case SUB_OP:
		lex();
		switch (nextToken) { // 상수 변수 '인 경우
		case INT_LIT: result = stoi(lexeme()); break;
		case DOUBLE_LIT: result = stod(lexeme()); break;
		case IDENT: result = *(start->find(lexeme(),start)); break;
		case QUOTE_CODE: //result = quote(); break;
		case LEFT_PAREN:
			if (isReturnNum()) {
				result = returnIsNum();
				lex();
				if (nextToken != RIGHT_PAREN) error();
			}
		default:error();
		}
		lex();
		switch (nextToken) { // 상수 변수 '인 경우
		case INT_LIT: result = result - stoi(lexeme()); break;
		case DOUBLE_LIT: result = result - stod(lexeme()); break;
		case IDENT: result = result - *(start->find(lexeme(),start)); break;
		case QUOTE_CODE: //result = result - quote(); break; //quote가 숫자를 반환하는지 확인이 필요함
		case LEFT_PAREN:
			if (isReturnNum()) {
				result = result - returnIsNum();
				lex();
				if (nextToken != RIGHT_PAREN) error();
			}
		default:error();
		}
		break;
	case MULT_OP:
		lex();
		switch (nextToken) { // 상수 변수 '인 경우
		case INT_LIT: result = stoi(lexeme()); break;
		case DOUBLE_LIT: result = stod(lexeme()); break;
		case IDENT: result = *(start->find(lexeme(),start)); break;
		case QUOTE_CODE:// result = quote(); break;
		case LEFT_PAREN:
			if (isReturnNum()) {
				result = returnIsNum();
				lex();
				if (nextToken != RIGHT_PAREN) error();
			}
		default:error();
		}
		lex();
		switch (nextToken) { // 상수 변수 '인 경우
		case INT_LIT: result = result * stoi(lexeme()); break;
		case DOUBLE_LIT: result = result * stod(lexeme()); break;
		case IDENT: result = result * *(start->find(lexeme(),start)); break;
		case QUOTE_CODE: //result = result * quote(); break; //quote가 숫자를 반환하는지 확인이 필요함
		case LEFT_PAREN:
			if (isReturnNum()) {
				result = result * returnIsNum();
				lex();
				if (nextToken != RIGHT_PAREN) error();
			}
		default:error();
		}
		break;
	case DIV_OP:
		lex();
		switch (nextToken) { // 상수 변수 '인 경우
		case INT_LIT: result = stoi(lexeme()); break;
		case DOUBLE_LIT: result = stod(lexeme()); break;
		case IDENT: result = *(start->find(lexeme(),start)); break;
		case QUOTE_CODE: //result = quote(); break;
		case LEFT_PAREN:
			if (isReturnNum()) {
				result = returnIsNum();
				lex();
				if (nextToken != RIGHT_PAREN) error();
			}
		default:error();
		}
		lex();
		switch (nextToken) { // 상수 변수 '인 경우
		case INT_LIT: result = result / stoi(lexeme()); break;
		case DOUBLE_LIT: result = result / stod(lexeme()); break;
		case IDENT: result = result / *(start->find(lexeme(),start)); break;
		case QUOTE_CODE: //result = result / quote(); break; //quote가 숫자를 반환하는지 확인이 필요함
		case LEFT_PAREN:
			if (isReturnNum()) {
				result = result / returnIsNum();
				lex();
				if (nextToken != RIGHT_PAREN) error();
			}
		default:error();
		}
		break;
	case SETQ_CODE: // (SETQ (x) (3))( <변수명(string)> <원소>) return 원소 // 여기선 전부 숫자 반환
		lex();
		if (nextToken == IDENT) {
			lex();
			//if()
			//result = 
		}
		else error();
	case CAR_CODE:
	case CDR_CODE:
	case NTH_CODE:
	case LENGTH_CODE:
	case SUBST_CODE:
	default: error();
	}
	return result;
}

var Parser::returnIsList(void) { // return 값이 list인 모든 데이터, 함수들 
	var var;
	return var;
}
var Parser::returnIsStr(void) { // return 값이 str인 모든 데이터, 함수들 
	var var;
	return var;
}
var Parser::returnIsF(void) {
	var var;
	return var;
}
var Parser::returnIsTF(void) {
	var var;
	return var;
}


/*var& Parser::stmt_list(void) { //
	var result;
	lex();
	switch (nextToken)
	{
	case ADD_OP : // 인자에 4 또는 변수 또는 (stmt_list)(return 값이 숫자) 또는 ' 올 수 있음.
		lex();
		switch (nextToken) { // 상수 변수 '인 경우
		case INT_LIT: result = stoi(lexeme()); break;
		case DOUBLE_LIT: result = stod(lexeme()); break;
		case IDENT: result = *(start->find(lexeme())); break;
		case QUOTE_CODE: result = quote(); break;
		case LEFT_PAREN:
			if (isReturnNum()) {
				result = returnIsNum();
				lex();
				if (nextToken != RIGHT_PAREN) error();
			}
		default:error();
		}
		lex();
		switch (nextToken) { // 상수 변수 '인 경우
		case INT_LIT: result = result + stoi(lexeme()); break;
		case DOUBLE_LIT: result = result + stod(lexeme()); break;
		case IDENT: result = result + *(start->find(lexeme())); break;
		case QUOTE_CODE: result = result + quote(); break; //quote가 숫자를 반환하는지 확인이 필요함
		case LEFT_PAREN:
			if (isReturnNum()) {
				result = result + returnIsNum();
				lex();
				if (nextToken != RIGHT_PAREN) error();
			}
		default:error();
		}
		break;
	case SUB_OP :
		lex();
		switch (nextToken) { // 상수 변수 '인 경우
		case INT_LIT: result = stoi(lexeme()); break;
		case DOUBLE_LIT: result = stod(lexeme()); break;
		case IDENT: result = *(start->find(lexeme())); break;
		case QUOTE_CODE: result = quote(); break;
		case LEFT_PAREN:
			if (isReturnNum()) {
				result = returnIsNum();
				lex();
				if (nextToken != RIGHT_PAREN) error();
			}
		default:error();
		}
		lex();
		switch (nextToken) { // 상수 변수 '인 경우
		case INT_LIT: result = result - stoi(lexeme()); break;
		case DOUBLE_LIT: result = result - stod(lexeme()); break;
		case IDENT: result = result - *(start->find(lexeme())); break;
		case QUOTE_CODE: result = result - quote(); break; //quote가 숫자를 반환하는지 확인이 필요함
		case LEFT_PAREN:
			if (isReturnNum()) {
				result = result - returnIsNum();
				lex();
				if (nextToken != RIGHT_PAREN) error();
			}
		default:error();
		}
		break;
	case MULT_OP :
		lex();
		switch (nextToken) { // 상수 변수 '인 경우
		case INT_LIT: result = stoi(lexeme()); break;
		case DOUBLE_LIT: result = stod(lexeme()); break;
		case IDENT: result = *(start->find(lexeme())); break;
		case QUOTE_CODE: result = quote(); break;
		case LEFT_PAREN:
			if (isReturnNum()) {
				result = returnIsNum();
				lex();
				if (nextToken != RIGHT_PAREN) error();
			}
		default:error();
		}
		lex();
		switch (nextToken) { // 상수 변수 '인 경우
		case INT_LIT: result = result * stoi(lexeme()); break;
		case DOUBLE_LIT: result = result * stod(lexeme()); break;
		case IDENT: result = result * *(start->find(lexeme())); break;
		case QUOTE_CODE: result = result * quote(); break; //quote가 숫자를 반환하는지 확인이 필요함
		case LEFT_PAREN:
			if (isReturnNum()) {
				result = result * returnIsNum();
				lex();
				if (nextToken != RIGHT_PAREN) error();
			}
		default:error();
		}
		break;
	case DIV_OP :
		lex();
		switch (nextToken) { // 상수 변수 '인 경우
		case INT_LIT: result = stoi(lexeme()); break;
		case DOUBLE_LIT: result = stod(lexeme()); break;
		case IDENT: result = *(start->find(lexeme())); break;
		case QUOTE_CODE: result = quote(); break;
		case LEFT_PAREN:
			if (isReturnNum()) {
				result = returnIsNum();
				lex();
				if (nextToken != RIGHT_PAREN) error();
			}
		default:error();
		}
		lex();
		switch (nextToken) { // 상수 변수 '인 경우
		case INT_LIT: result = result / stoi(lexeme()); break;
		case DOUBLE_LIT: result = result / stod(lexeme()); break;
		case IDENT: result = result / *(start->find(lexeme())); break;
		case QUOTE_CODE: result = result / quote(); break; //quote가 숫자를 반환하는지 확인이 필요함
		case LEFT_PAREN:
			if (isReturnNum()) {
				result = result / returnIsNum();
				lex();
				if (nextToken != RIGHT_PAREN) error();
			}
		default:error();
		}
		break;
	case IDENT:
		if (findVar(lexeme()) == -1) error();
		return findVar(lexeme());
	case INT_LIT: return stoi(lexeme());
	case DOUBLE_LIT: return stod(lexeme());
	case SETQ_CODE: setq(); break;
	case LIST_CODE: list(); break;
	case CAR_CODE: car(); break;
	case CDR_CODE: cdr(); break;
	case NTH_CODE: nth(); break;
	case CONS_CODE: cons(); break;
	case REVERSE_CODE: reverse(); break;
	case APPEND_CODE: append();  break;
	case LENGTH_CODE: length();  break;
	case MEMBER_CODE: member() : break;
	case ASSOC_CODE: assoc(); break;
	case REMOVE_CODE: remove(); break;
	case SUBST_CODE: subst(); break;
	case ATOM_CODE: atom(); break;
	case NULL_CODE: null(); break;
	case NUMBERP_CODE: numberp(); break;
	case ZEROP_CODE: zerop(); break;
	case MINUSP_CODE: minusp(); break;
	case EQUAL_CODE: equal(); break;
	case STRINGP_CODE: stringp(); break;
	case IF_CODE: if(); break;
	case COND_CODE: cond(); break;
	case QUOTE_CODE: queot(); break;
	default: error();
	}
	return result;
}*/
bool Parser::isReturnNum(void) {
	switch (nextToken) {
	case SETQ_CODE:case CAR_CODE:case CDR_CODE:case NTH_CODE:case LENGTH_CODE:
	case SUBST_CODE:case ADD_OP:case SUB_OP:case MULT_OP:case DIV_OP:
		return true;
	}
	error();
	return false;
	;
} //return 값이 숫자인 모든 데이터,함수들 (후보를 갖고 있으면 전부 포함)
bool Parser::isReturnList(void) {
	switch (nextToken) {
	case SETQ_CODE:case LIST_CODE:case CAR_CODE:case CDR_CODE:case NTH_CODE:case CONS_CODE: case REVERSE_CODE: case APPEND_CODE:
	case MEMBER_CODE: case ASSOC_CODE: case REMOVE_CODE:case SUBST_CODE:
		return true;
	}
	error();
	return false;
	;
} // return 값이 list인 모든 데이터, 함수들 
bool Parser::isReturnStr(void) {
	switch (nextToken) {
	case SETQ_CODE:case CAR_CODE:case CDR_CODE:case NTH_CODE: case SUBST_CODE:
		return true;
	}
	error();
	return false;
}
bool Parser::isReturnF(void) { //NIL만 가능
	switch (nextToken) {
	case SETQ_CODE:case CAR_CODE:case CDR_CODE:case NTH_CODE: case MEMBER_CODE: case ASSOC_CODE: case REMOVE_CODE: case SUBST_CODE:
		return true;
	}
	error();
	return false;
}
bool Parser::isReturnTF(void) {
	switch (nextToken) {
	case ATOM_CODE:case NULL_CODE:case NUMBERP_CODE:case ZEROP_CODE: case MINUSP_CODE:
	case EQUAL_CODE: case STRINGP_CODE: case QUOTE_CODE:
		return true;
	}
	error();
	return false;
}
bool Parser::isCondition(void) {
	switch (nextToken) {
	case IF_CODE: case COND_CODE:
		return true;
	}
	error();
	return false;
}
void error() {
	cout << "문법에 맞지 않습니다." << endl;
}
string Parser::lex() {
	nextToken = lexer.lex();
	cout << lexer.lexeme << " ";
	return lexer.lexeme;
}
string Parser::lexeme() {
	return lexer.lexeme;
}

/*
int Parser::expr() {
	printf("Enter <expr>\n");
	int result = 0;
	result = term();

	while (nextToken == ADD_OP) {
		lex();
		result += term();
	}
	while (nextToken == SUB_OP) {
		lex();
		result -= term();
	}
	printf("Exit <expr>\n");
	return result;
}

int Parser::term() {
	int result = 0;
	printf("Enter <term>\n");

	result = factor();


	while (nextToken == MULT_OP) {
		lex();
		result /= factor();
	}
	while(nextToken == DIV_OP) {
	lex();
	result *= factor();
	}
	printf("Exit <term>\n");
	return result;
}

int Parser::factor() {
	printf("Enter <factor>\n");
	//printf("%d\n", nextToken);

	int result;
	if (nextToken == IDENT || nextToken == INT_LIT) {
		result = stoi(lexeme());
		lex();
	}


	else if (nextToken == LEFT_PAREN) {
		lex();
		result = expr();
		if (nextToken == RIGHT_PAREN) {
			lex();
		}
		else error();
	}

	else error();
	printf("exit <factor>\n");
	return result;

	double Parser::prefixcal(void) {
	double result;
	vector<string> stack;
	vector<string> stack;
	stack.push_back(lexeme());
	stack.push_back(lex());
	for (int i = 0; i < ; i++) {
	}
	lex();
	return result;
}
void Parser::setq() {
	lex();
	string var_name;
	double var_value;
	if (nextToken == IDENT) {
		var_name = lexeme();
		lex();
		if (nextToken == DOUBLE_LIT || nextToken == INT_LIT) {
			var_value = stod(lexeme());
			if (lex() == ")") {
				variable.push_back(make_pair(var_name,var_value));
			}
			else error();
		}
		else error();
	}
	else error();
	cout << var_value << endl;
}
}*/